\documentclass[french]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage[french]{babel}
\usepackage{color}
\usepackage{colortbl}
\usepackage{listings}
\usepackage{pxfonts}
\usepackage[french]{algorithm2e}
\usepackage{url}
\usepackage{stmaryrd}
\usepackage{wrapfig}
\usepackage{textcomp} % \textlnot

% User packages
\usepackage{lstlangarm}

\lstset{
    language=Caml,
    basicstyle=\ttfamily,
    keywordstyle=\color[rgb]{0.5,0,0}\bfseries,
    commentstyle=\color[rgb]{0.133,0.545,0.133},
    showstringspaces=false,
    frame=tb,
    columns=fullflexible,
    morekeywords={undefined}
}

\definecolor{Gray}{gray}{0.85}

\makeatletter
\renewcommand{\@algocf@capt@plain}{above}% formerly {bottom}
\newcommand{\pushline}{\Indp} % Indent
\newcommand{\popline}{\Indm}  % Undent
\newcommand{\pushright}[1]{\ifmeasuring@#1\else\omit\hfill$\displaystyle#1$\fi\ignorespaces} % push to right
\newcommand{\pushleft}[1]{\ifmeasuring@#1\else\omit$\displaystyle#1$\hfill\fi\ignorespaces} % push to left
\makeatother

\begin{document}
  \begin{titlepage}
  \newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
  \center 
  \textsc{\	 IRIT - Equipe TRACES}\\[1.5cm] \textsc{\Large Rapport de Stage - M2R IT Spé. SRLC}\\[0.5cm] 
  \textsc{\large 01 Mars 2014 - 03 Août 2014}
  \HRule \\[0.5cm] { \huge \bfseries Détermination de propriétés de flot de données pour l'amélioration du temps d'exécution
pire-cas}\\[0.4cm] \HRule \\[1cm]
  \begin{minipage}{0.5\textwidth} \begin{flushleft} \large \emph{Auteur:}\\ Jordy \textsc{Ruiz} \end{flushleft} \end{minipage}\begin{minipage}{0.5\textwidth} \begin{flushright} \large \emph{Encadrant:} \\ Hugues \textsc{Cassé}\end{flushright} \end{minipage}\\[1cm]
  {\large Année 2013 - 2014}\\[2.5cm]
  \includegraphics[scale=0.6]{pictures/logo_univ_tlse.png}\\[1cm]
  \vfill
  \end{titlepage}
  
  %\selectlanguage{french}
  \pagebreak{}
  %\tableofcontents{}
  \newpage{}

  \section{Introduction}
  \subsection{WCET, les enjeux}
  \`A Toulouse même, les besoins des industriels en termes de vérification de logiciel sont présents. Le calcul du pire temps d'exécution, ou WCET en anglais (Worst Case Execution Time) est un de ces multiples processus de vérification. La grande majorité des logiciels développés n'ont pas besoin de tels procédés de vérification, les bugs y sont gênants mais la plupart du temps on redémarre sans trop chercher à comprendre. Pour les systèmes dits \textbf{temps-réel critiques} (algorithme dans un satellite, frein d'une voiture, pilotage d'une rame de métro...), une erreur ou un échec peuvent entraîner de lourdes pertes économiques ou humaines : le plantage du logiciel d'un satellite nécessite des interventions très coûteuses, le temps de réponse exceptionnellement long d'un frein de voiture peut entraîner un accident...
  
  Le problème est simple : il peut exister dans ces systèmes temps-réel critiques des cas extrêmement rares, indétectables par une batterie de tests, où le temps d'exécution explose anormalement. On pourrait par exemple imaginer un algorithme qui sauvegarde (disons hebdomadairement) le contenu de ses données sur un disque externe. Si tout est géré de manière synchrone et qu'un ordre critique arrive à ce moment-là, on pourrait se retrouver avec un temps d'exécution très élevé. On peut imaginer plein d'autres exemples (une plage de données très fragmentée qui entrainerait des défauts de page en masse, etc...).
  
  Dans le cadre de mon étude, je fais abstraction de certains problèmes très bas niveau comme la gestion du cache ou le fonctionnement du pipeline et des prédictions de branchement. Ces problèmes ne sont pas ignorés, ils sont simplement traités par d'autres travaux, d'autres outils que les miens.
  
  Le calcul du WCET consiste en une \textbf{surestimation} : on ne donne certes pas une mesure exacte du pire temps d'exécution, mais on garantit que cette mesure est en tout cas supérieure au pire temps réel. Le but de mon étude est d'améliorer, d'affiner, donc de \textbf{réduire} la surestimation du WCET calculée par notre outil OTAWA, tout en restant correct. On cherche à avoir le plus petit majorant possible.
  
  La stratégie que je vais mettre en oeuvre pour la réduction de notre évaluation du WCET est la recherche de chemins infaisables.
  
  \subsection{La recherche de chemins infaisables}
  L'idée est la suivante : pour (sur)estimer le WCET, notre outil OTAWA fonctionne par énumération implicite des ``chemins'' du programme, ou IPET en anglais (Implicit Path Enumeration Technique), il prendra ensuite le temps d'exécution du chemin le plus coûteux du programme pour le calcul du WCET. Les programmes étudiés contiennent souvent de nombreux chemins infaisables (une étude avait observé 99.9\% de chemins infaisables dans un programme de gestion des vitres d'une voiture). Prenons par exemple le programme suivant :
  
  \RestyleAlgo{boxed}
  \begin{algorithm}
    \Donnees{n}
    \Res{k}
    \eSi{n > 10}{
	k = 0; // (1)\\
	sauvegarder();
    }{
	k = 1; // (2)
    }
    \eSi{n > 0}{
	k = k + 1; // (3)
    }{
	k = k - 1; // (4)\\
	sauvegarder();
    }
    \label{alg:1}
    \caption{Exemple d'un programme avec chemin infaisable}
  \end{algorithm}
  
  Ce programme contient 4 chemins :
  \begin{itemize}
    \item Un chemin $c_1$ qui passe par (1) et (3) ;
    \item Un chemin $c_2$ qui passe par (1) et (4) ;
    \item Un chemin $c_3$ qui passe par (2) et (3) ;
    \item Un chemin $c_4$ qui passe par (2) et (4).
  \end{itemize}
  
  Le chemin $c_2$, qui passe par (1) et (4) est \textbf{infaisable}, puisqu'il implique $n > 10$ et $n \ngtr 0$.
  
  On pourrait maintenant imaginer que la fonction \texttt{sauvegarder} fait une opération relativement coûteuse, comme par exemple une écriture sur un fichier du système. Dans ce cas, le WCET calculé correspondra au temps d'exécution du chemin $c_2$, qui vaut à peu près à deux fois le temps d'exécution de la fonction \texttt{sauvegarder}.
  
  Or, ce chemin est infaisable, c'est-à-dire qu'il ne sera jamais emprunté par le programme. Dans la réalité, ce programme n'exécuterait au plus qu'une fois cette fonction de sauvegarde, nous avons donc estimé le WCET (à peu près) au double du WCET réel !
  
  En détectant ce chemin infaisable $c_2$, on pourrait indiquer à OTAWA de ne pas considérer ce chemin, et ainsi réduire effectivement l'estimation du WCET obtenue de moitié.
  
  Le but de mon étude est donc de détecter ces chemins infaisables et de transmettre cette information à l'outil avant qu'il ne démarre son analyse pour l'estimation du WCET.

  
  \subsection{Langages supportés}
  Notre analyse portera sur des programmes écrits en \textbf{langage assembleur}, qui est le langage de programmation le plus proche de la machine. Le travail sur le code source a effectivement de multiples inconvénients : il faut prouver le(s) compilateur(s) qui viennent avec (un travail très conséquent), et cela nous restreint aussi aux programmes dont nous disposons des sources complètes (certaines bibliothèques ne sont pas open-source).
  
  Le langage assembleur, aussi appelé langage machine, est en revanche bien sûr beaucoup moins facile à analyser : les registres ne sont en général pas typés, et il n'y a pas réellement d'instructions \texttt{if}, \texttt{then}, \texttt{else} ou \texttt{while}, \texttt{for} (celle-ci est particulièrement dure à détecter dans le code assembleur) : il s'agit seulement d'instructions de comparaison et de branchements conditionnels. 
  
  Il n'y a pas non plus d'appels de fonctions avec des paramètres et des valeurs de retours explicites, il s'agit là encore de branchements (BL, Branch with Link dans le cas du langage d'assembleur ARM~\cite{ARM instruction set}).
  
  Un autre problème des langages machines est qu'il sont spécifiques à une architecture, les exécutables compilés à partir d'un même langage source seront différent selon qu'on est sur une architecture ARM ou PowerPC... Fort heureusement, notre outil OTAWA nous permet de nous \textbf{abstraire de l'architecture} en transformant les instructions du langage assembleur en \textbf{instructions sémantiques} génériques, universelles à tous les langages assembleur. % TODO: what is going on with the text align o_o
  
  Ainsi, l'analyse que je développerai avec OTAWA supportera toutes les architectures supportées par OTAWA, et pour supporter une nouvelle architecture, il suffit de rajouter celle-ci dans OTAWA. OTAWA fonctionne comme une interface entre l'analyse et le code (écrit dans un langage spécifique à une architeture). Cette interface est schématisée sur la figure~\ref{abstraction architecture}.
  
  \begin{figure}
    \centering
    \includegraphics[width=\textwidth]{pictures/otawa_abstraction_architecture.png}
    \caption{OTAWA permet aux analyses de s'abstraire de l'architecture}
    \label{abstraction architecture}
  \end{figure}
  
  Voici, sans donner plus de détails pour le moment, à quoi ressemble la traduction de code assembleur (celui-ci a été généré avec gcc) en instructions sémantiques. Les \texttt{tX} sont des variables temporaires utilisées pour la traduction en instructions sémantiques et les \texttt{?X} sont les registres. Pour chaque instruction assembleur, on trouve dessous une ou plusieurs instructions sémantiques équivalentes, en commentaire :
  
  \begin{lstlisting}[language={[ARM]Assembler}]
    ldr r0, [pc, #20]
    @	seti ?15, 0x8310
    @	seti t2, 0x14
    @	add t1, ?15, t2
    @	load ?0, t1, uint32
    
    mov r1, #0
    @	seti ?1, 0x0
    
    mov r2, r1
    @	set t1, ?1
    @	set ?2, t1
    
    bl 8574
    @	seti t1, 0x8574
    @	seti ?14, 0x8318
    @	branch t1
  \end{lstlisting}
  
  De plus amples explications à ce sujet seront données dans la suite de ce mémoire.
  
  \subsection{Restrictions}
  Nous travaillons dans le cadre de cette étude exclusivement sur des programmes sans boucles. Le problème de la gestion des boucles est un problème complexe qui ne pouvait pas se traiter en l'espace de quelques mois. Cette hypothèse n'est pas complètement irréaliste puisqu'il existe des programmes, ou même des langages assembleur sans boucles. Plus tard quand ce travail sera continué en thèse, il faudra les traiter mais nous ne savons pas encore à quel point ce traitement sera limité en efficacité.
  
  Un autre vaste problème se pose, celui de la gestion de la mémoire. Il s'agit de se représenter dans le programme l'état de la mémoire (ou du moins les quelques parties sur lesquelles on sait quelque chose) et de déduire des propriétés sur la valeur du registre de destination d'un LOAD en mémoire. Le traitement des instructions mémoire est à l'heure que j'écris ces lignes quasiment terminé mais il reste assez limité.
  
  Notre programmme ne traite pour l'instant pas les instructions sémantiques d'OTAWA spécifiques aux ``unsigned'' (entiers représentés non signés). En effet, pour une même valeur binaire dans un registre, selon qu'on l'interprète comme un entier signé ou non, son interprétation peut être différente. Un exemple sur 4 bits est donné sur la figure~\ref{representation_signed_unsigned}.
  
  \begin{figure}
    \centering
    \includegraphics[width=250px]{pictures/representation_signed_unsigned.png}
    \caption{Différentes interprétations de la valeur d'un registre}
    \label{representation_signed_unsigned}
  \end{figure}

  Toutefois, l'interprétation de la valeur d'un registre est identique tant que le bit de poids fort est à 0, c'est à dire tant que la valeur interprétée appartient à l'intervalle $\llbracket0, 2^{n-1}-1\rrbracket$, où $n$ est le nombre de bits du registre.
  
  Et bien sûr, toutes les instructions qui ne sont pas supportées par OTAWA (impossibles à traduire en expression sémantiques) ne sont pas non plus supportées par notre programme, même si ce type d'erreur est géré de manière à ne pas être critique : on va perdre de l'information et donc peut-être détecter moins de chemins infaisables, mais l'analyse n'échoue pas.
  
  \section{Brouillon}
  \subsection{Choix du solveur SMT}
  Pour le choix de notre solveur SMT, nous avons dressé un petit état de l'art en nous basant principalement sur des résultats de la SMT-COMP~\cite{SMT-COMP}, une compétition entre solveurs, en éliminant d'office les solveurs qui ne présentaient pas d'API utilisable en C++ :
  
  \begin{itemize}
    \item Z3~\cite{smt_z3}
    \begin{itemize}
      \item Gagnant de la SMT-COMP 2011
      \item Apparemment encore le plus performant en termes de temps d'exécution
      \item Développé par Microsoft Research
      \item Distribué sous la licence \textit{Microsoft Research License Agreement Non-Commercial Use Only}
    \end{itemize}
    \item CVC4~\cite{smt_cvc4}
    \begin{itemize}
      \item CVC3 a l'air insuffisant et limité mais le solveur a été globalement réécrit pour CVC4, bien qu'il semble y avoir une certaine continuité dans les \textit{features} proposées
      \item CVC4 a tourné sur de multiples benchmarks et a toujours eu de bons ou très bons résultats
      \item Open source, sans restriction pour un usage commercial ou à fins de recherches
    \end{itemize}
    \item MathSAT 5~\cite{smt_mathsat5}
    \begin{itemize}
      \item API disponible seulement en C
      \item Bons résultats pour MathSAT5-smtcomp12
      \item ``An SMT solver for Formal Verification'', ouverture possible sur la vérification formelle
    \end{itemize}
    \item Boolector~\cite{smt_boolector}
    \begin{itemize}
      \item API disponible seulement en C
      \item Quelques très bons résultats à la SMT-COMP mais qui ne semblent pas porter sur des critères intéressants pour notre usage.
    \end{itemize}
    \item SONOLAR~\cite{smt_sonolar}
    \begin{itemize}
      \item Modeste dans ses performances
      \item N'a été testé que sur benchmarks notés ``BV'', restrictions aux booléens ?
    \end{itemize}
    \item MISTRAL~\cite{smt_mistral}
    \begin{itemize}
      \item Pas évalué à la SMT-COMP 2012
    \end{itemize}
    \item VeriT~\cite{smt_verit}
    \begin{itemize}
      \item Pas évalué à la SMT-COMP 2012
    \end{itemize}
    \item Barcelogic~\cite{smt_barcelogic}
    \begin{itemize}
      \item Pas évalué à la SMT-COMP 2012
    \end{itemize}
  \end{itemize}
  
  \begin{wrapfigure}{R}{1.5in}
    \centering
    \includegraphics{./pictures/cvc4.png}
    % cvc4.png: 300x168 pixel, 300dpi, 2.54x1.42 cm, bb=0 0 72 40
    \label{cvc4}
  \end{wrapfigure}
  
  Notre choix s'est finalement porté sur \textbf{CVC4}, pour ses bonnes performances, son API riche et bien documentée, et sa licence très libre.
  
  Notre application utilise toutefois ses propres structures pour manipuler les prédicats, et le module qui fait l'interface avec le solveur SMT devrait être suffisamment indépendant du reste pour permettre de changer de solveur SMT si besoin sans trop de difficultés.
  
  \subsection{Représentation en graphe de flot de contrôle}
  Lors de notre analyse, nous considérerons le programme sous la forme d'un graphe connexe enraciné, appelé \textbf{graphe de flot de contrôle, ou CFG} (Control Flow Graph). Dans le cas des programmes sans boucles que nous traitons, il s'agit même d'un arbre.
  
  Un CFG est donc un graphe dont les noeuds sont appelés des \textbf{blocs de bases}, et qui sont constitués d'une suite d'instructions exécutées \textit{séquentiellement}. Il ne peut donc y avoir d'appels de fonctions, de conditions, de boucles, ou tout autre branchement à l'intérieur d'un bloc de base (excepté en dernière instruction). La figure~\ref{bloc de base} en montre un exemple.
  
  \begin{figure}
    \centering
    \includegraphics[scale=0.5]{pictures/basicblock.png}
    % basicblock.png: 173x104 pixel, 72dpi, 6.10x3.67 cm, bb=0 0 173 104
    \caption{Un exemple de bloc de base en langage machine ARM}
    \label{bloc de base}
  \end{figure}
  
  Les arêtes représentent les chemins d'exécution du programme, elles correspondent à des branchements où à l'exécution séquentielle du programme. Il y a deux types de branchements : les branchements conditionnels et les branchements inconditionnels.
  
  Parmi les \textbf{branchements conditionnels}, ceux qui correspondent à l'arc ``pris'', c'est-à-dire au cas où la condition évoquée est vérifiée, sont annotés sur le CFG avec l'étiquette ``\textit{taken}'', l'arc dit ''non pris'' n'a conventionellement pas d'étiquette.
  
  Parmi les \textbf{branchements inconditionnels}, il peut s'agit de l'exécution séquentielle du programme ou d'un branchement non conditionnel (ce qui revient en assembleur à changer le registre pointeur d'instruction \texttt{pc} ou \texttt{r15}) auquel cas l'arc n'est pas annoté, ou il peut s'agit d'un appel de fonction (\textit{Branch with Link} en assembleur), auquel cas l'arc est dessiné en pointillés et annoté ``\textit{call}''.
  
  Les figures \ref{branchement conditionnel} et \ref{branchement inconditionnel} montrent des exemples de ces branchements.
  
  \begin{figure}
    \begin{minipage}[c]{.46\linewidth}
      \includegraphics[scale=0.5]{./pictures/conditional_branch.png}
      % conditional_branch.png: 419x248 pixel, 96dpi, 11.08x6.56 cm, bb=0 0 314 186
      \caption{Exemples de branchements conditionnels}
      \label{branchement conditionnel}
   \end{minipage} \hfill
   \begin{minipage}[c]{.46\linewidth}
      \includegraphics[scale=0.5]{./pictures/incoditional_branch.png}
      % incoditional_branch.png: 423x181 pixel, 96dpi, 11.19x4.79 cm, bb=0 0 317 136
      \caption{Exemples de branchements inconditionnels}
      \label{branchement inconditionnel}
   \end{minipage}
\end{figure}

  % TODO expliquer plus en détail/formellement les CFGs ici
  
  \bigbreak
  
  Prenons pour exemple l'algorithme~\ref{alg:1} que nous avions présenté plus haut. Le CFG en pseudo-code correspondant est exhibé sur la figure~\ref{cfg}. On y voit bien apparaître les 4 chemins cités précédemment. %TOLDO: vérifier que l'algo soit bien présent *plus haut*
  
  La figure~\ref{cfg_genere} montre le CFG généré par OTAWA à partir du code ARM correspondant à l'algorithme~\ref{alg:1} (compilé à partir d'un fichier C). On y observe à peu près la même structure que sur le CFG en pseudo-code, avec des calls à la fonction \texttt{sauvegarder} et des instructions ARM plus volumineuses à l'intérieur des blocs.
  
  \begin{figure}
    \centering
    \includegraphics[height=250px]{pictures/cfg.png}
    \caption{CFG de l'algorithme~\ref{alg:1}}
    \label{cfg}
  \end{figure}
  
  \begin{figure}
    \centering
    \includegraphics[height=525pt]{pictures/cfg_genere.png}
    % cfg_genere.png: 468x1296 pixel, 72dpi, 16.51x45.72 cm, bb=0 0 468 1296
    \caption{CFG généré par OTAWA}
    \label{cfg_genere}
  \end{figure}

  
  
  \subsection{Analyse d'un graphe de flot de contrôle}
  Comme nous travaillons sans boucles, l'algorithme ci-dessous n'est pas correct, ou du moins ne terminera pas si on le fait fonctionner sur un CFG avec boucles. Nous initialisons d'abord l'algorithme de parcours de graphe de contrôle avec le premier bloc de base du CFG, qui nous est donné par OTAWA.
  
  Voici donc l'algorithme en pseudo-code, qui prend en paramètre un bloc de base :\\
  
   % http://www.cs.toronto.edu/~frank/Useful/algorithm2e.pdf
  \begin{algorithm}[H]
    % \caption{analyzeBasicBlock}
    \Donnees{bb: BasicBlock, lpreds: LabelledPredicate list}
    \Res{Chemins infaisables trouvés}
    \Si{bb est un bloc de sortie (EXIT)}{
        \Retour{[]} // Fin de l'analyse de ce chemin
    }
    Appeler le solveur SMT avec lpreds;\\
    \Si{on a trouvé une insatisfiabilité}{
	Extraire la liste des chemins infaisables;\\
	\Retour{cette liste} // Fin de l'analyse de ce chemin
    }
    preds = parseBasicBlock(bb); // Analyse linéaire des instructions sémantiques\\
    \Pour{tous les arcs sortants edge de bb}{
	Labeller les prédicats preds avec l'arc edge comme étiquette;\\
	Ajouter ces prédicats labellés à lpreds;\\
	Appel récursif de cette fonction avec pour paramètres (\\
	    \pushline le bloc de base vers lequel edge pointe,\\
	    la nouvelle liste lpreds\\
	\popline);\\
    }
  \end{algorithm}
  
  
  \subsection{Analyse des instructions sémantiques d'un bloc de base}
  Le programme parcourt les blocs de base linéairement en mettant à jour la liste de prédicats.

  Nous définissons d'abord une fonction d'invalidation d'une variable dans la liste de prédicats, qui consiste à supprimer tous les prédicats qui utilisent cette variable.

  \begin{lstlisting}[mathescape]
    invalidate var p =
        {predicate $\in$ p $|$ var $\notin$ predicate}
  \end{lstlisting}

  Il s'agit maintenant de définir l'effet de la lecture de chaque instruction sur la liste de prédicats.
  Exemple sur un premier cas trivial :

  \begin{lstlisting}
    t [NOP] p =
        p (* rien ne change *)
  \end{lstlisting}

  La fonction de traduction \texttt{t} opère sur une instruction (ici \texttt{NOP}) et la liste de prédicats \texttt{p}.

  Regardons maintenant comment est traitée l'instruction d'assignation d'une variable à une autre variable (\texttt{SET}) :

  \begin{lstlisting}
    t [SET d a] p =
        (d = a) @ (invalidate d p)
  \end{lstlisting}

  Un nouveau prédicat \texttt{d = a} est généré après qu'on ait invalidé \texttt{d}, c'est-à-dire qu'on ait supprimé tous les prédicats qui contiennent t.
  De même pour l'instruction \texttt{SETI} qui assigne une constante à une variable.

  \begin{lstlisting}
    t [SETI d cst] p =
        (d = a) @ (invalidate d p)

    t [CMP d a b] p =
        (d = a ~ b) @ (invalidate d p)
    \end{lstlisting}

    Cet opérateur $\sim$ bien spécifique aux langages d'assembleur sert à se souvenir que
    \texttt{d} contient des informations sur la comparaison entre \texttt{a} et \texttt{b}.

    Pour la suite nous allons avoir besoin de la fonction \texttt{update} qui sert à remplacer
    toutes les occurences d'une variable \texttt{var} par l'expression \texttt{expr} dans la liste de prédicats \texttt{p} :

  \begin{lstlisting}[mathescape]
    update var expr p =
        {predicate[expr / var] $|$ predicate $\in$ p}
  \end{lstlisting}

  où la syntaxe \texttt{predicate[expr / var]} dénote ici le prédicat où le terme \texttt{var} est remplacé par l'expression \texttt{expr}.

  \begin{lstlisting}[mathescape]
    t [ADD d a b] p =
        if (d = a) then (* d <- d+b *)
            (update d (d - b) p)
        else if (d = b) (* d <- a+d *)
            (update d (d - a) p)
        else
            (d = a + b) @ (invalidate d p)

    t [SUB d a b] p =
        if (d = a) then
            if (d = b) then (* d <- d-d *)
                (update d 0 p)
            else (* d <- d-b *)
                (update d (d+b) p)
        else
            if (d = b) then (* d <- a-d *)
                (update d (a-d) p)
            else (* d <- a-b *)
                (d = a - b) @ (invalidate d p)

    t [MUL d a b] p =
        if (d = a) then
            if (d = b) then (* d <- d*d *)
                (* impossible de remplacer d par $\sqrt{d}$, on invalide *)
                (0 <= d) @ (invalidate d p)
            else (* d <- d*b *)
                (* on rajoute un predicat pour indiquer que d est
                   divisible par b *)
                (d % b = 0) @ (update d (d/b) p)
        else
            if (d = b) then (* d <- a*d *)
                (d % a = 0) @ (update d (d/a) p)
            else (* d <- a*b *)
                (d = a * b) @ (invalidate d p)

    t [DIV d a b] p =
        if (d = a) then
            if (d = b) then (* d <- d/d *)
                (d = 1) @ (invalidate d p)
            else (* d <- d/b *)
                (* impossible de remplacer d par (d*b),
                   on a perdu de l'information ! *)
                (invalidate d p)
        else
            if (d = b) then (* d <- a/d *)
                (invalidate d p)
            else (* d <- a/b *)
                (d = a / b) @ (invalidate d p)
  \end{lstlisting}

  Pour illustrer le problème de l'instruction DIV, prenons le cas où l'on a \texttt{\{t1 = 7, t2 = 3\}} et une instruction \texttt{[DIV t1 t1 t2]}.\\
  En remplaçant \texttt{t1} par \texttt{t1 * t2}, on obtiendrait \texttt{\{(t1 * t2 = 7), (t2 = 3)\}}, c'est-à-dire \texttt{(t1 * 3 = 7)}, ce qui est impossible puisqu'on travaille sur des entiers !

  \begin{lstlisting}
    t [MOD d a b] p =
        if (d = a or d = b)
            (invalidate d p)
        else
            (d = a % b) @ (invalidate d p)
  \end{lstlisting}

  Nous utiliserons dans la suite une fonction \texttt{eval} qui cherche la valeur \textbf{constante} pour une variable.
  La fonction eval parcourt donc la liste des prédicats à la recherche de prédicats du type \texttt{(var = 2)} permettant
  d'identifier la valeur de \texttt{var}.

  \begin{lstlisting}
    t [ASR d a b] p =
        let b_val = eval b in
        if b_val = undefined then
            (invalidate d p)
        else
            let factor = 2 ** b_val in
            if (d = a) then (* d <- d>>b *)
                (update d (d / factor) p)
            else (* d <- a>>b *)
                (d = a / factor) @ (invalidate d p)

    t [NEG d a] =
        if (a = d) (* d <- -d *)
            (update d (-d) p)
        else (* d <- -a *)
            (d = -a) @ (invalidate d p)
  \end{lstlisting}


  \begin{figure}
    \begin{tabular}{|l|l|} \hline
      \textbf{Instruction} & \textbf{Sémantique}\\ \hline \hline
      \texttt{NOP} & (rien)\\ \hline
      \texttt{BRANCH} & \\
      \texttt{TRAP} & Indicateurs du flot du programme\\
      \texttt{CONT} & \\ \hline
      \texttt{IF cond sr jump} & si la condition \texttt{cond} sur le registre \texttt{sr} est vraie, continuer,\\
      & sinon sauter \texttt{jump} instructions\\ \hline
      \texttt{LOAD reg addr type} & reg $\leftarrow$ \texttt{MEM\textsubscript{type}} \\ \hline
      \texttt{STORE reg addr type} & \texttt{MEM\textsubscript{type}} $\leftarrow$ \texttt{reg}\\ \hline
      \texttt{SCRATCH d} & \texttt{d $\leftarrow$ $\top$} \textit{(invalidation)}\\ \hline
      \texttt{SET d a} & \texttt{d $\leftarrow$ a}\\ \hline
      \texttt{SETI d cst} & \texttt{d $\leftarrow$ cst}\\ \hline
      \rowcolor{Gray} \texttt{SETP d cst} & \texttt{page(d) $\leftarrow$ cst}\\ \hline
      \texttt{CMP d a b} & \texttt{d $\leftarrow$ a $\sim$ b}\\ \hline
      \rowcolor{Gray} \texttt{CMPU d a b} & \texttt{d $\leftarrow$ a $\sim$\textsubscript{unsigned} b}\\ \hline
      \texttt{ADD d a b} & \texttt{d $\leftarrow$ a $+$ b}\\ \hline
      \texttt{SUB d a b} & \texttt{d $\leftarrow$ a $-$ b}\\ \hline
      \rowcolor{Gray} \texttt{SHL d a b} & \texttt{d $\leftarrow$ unsigned(a) <{<} b}\\ \hline
      \rowcolor{Gray} \texttt{SHR d a b} & \texttt{d $\leftarrow$ unsigned(a) >{>} b}\\ \hline
      \texttt{ASR d a b} & \texttt{d $\leftarrow$ a >{>} b}\\ \hline
      \texttt{NEG d a} & \texttt{d $\leftarrow$ $-$a}\\ \hline
      \rowcolor{Gray} \texttt{NOT d a} & \texttt{d $\leftarrow$ $\neg$a}\\ \hline
      \rowcolor{Gray} \texttt{AND d a b} & \texttt{d $\leftarrow$ a \& b}\\ \hline
      \rowcolor{Gray} \texttt{OR d a b} & \texttt{d $\leftarrow$ a | b}\\ \hline
      \rowcolor{Gray} \texttt{XOR d a b} & \texttt{d $\leftarrow$ a $\oplus$ b}\\ \hline
      \texttt{MUL d a b} & \texttt{d $\leftarrow$ a $\times$ b}\\ \hline
      \rowcolor{Gray} \texttt{MULU d a b} & \texttt{d $\leftarrow$ unsigned(a) $\times$ unsigned(b)}\\ \hline
      \texttt{DIV d a b} & \texttt{d $\leftarrow$ a / b}\\ \hline
      \rowcolor{Gray} \texttt{DIVU d a b} & \texttt{d $\leftarrow$ unsigned(a) / unsigned(b)}\\ \hline
      \texttt{MOD d a b} & \texttt{d $\leftarrow$ a \% b}\\ \hline
      \rowcolor{Gray} \texttt{MODU d a b} & \texttt{d $\leftarrow$ unsigned(a) \% unsigned(b)}\\ \hline
      \rowcolor{Gray} \texttt{SPEC} & (instruction spéciale non supportée par OTAWA)\\ \hline
    \end{tabular}
    \textit{En gris : les instructions qui ne sont pas (encore) traitées par notre analyse.}
    \caption{Liste des instructions sémantiques d'OTAWA}
  \end{figure}


  \section{Solution}
  Explication : calcul de WCET par IPET, max d'un système ILP\\
  Solution = Recherche de chemins infaisables pour améliorer l'estimation du WCET\\
  Parler des outils choisis (OTAWA + CVC4 ?)\\

  \section{Structures de données utilisées}
  La représentation des prédicats (associés à un Edge)\\
  => représentation également de la mémoire\\
  Traduction des prédicats dans le solveur SMT

  \section{Structure de l'algorithme}
  CFG : Représentation du programme sous la forme de graphe\\
  On parcourt tous les chemins\\
  On les représente sous la forme de prédicats (on y associe un arc du CFG\\
  On fait des appels au SMT pour vérifier la satisfiabilité\\
  Retourne la liste de prédicats\\
  On génère les contraintes ILP\\
  
  Identification des chemins infaisables ?
  
  \section{Traduction en contraintes ILP}
  Une fois les chemins infaisables trouvés, il faut générer des contraintes ILP sur le CFG utilisables par OTAWA pour affiner (du moins on l'espère) l'estimation du WCET.
  
  \subsection{Cas avec deux if en séquence}
  Commençons avec un exemple simple de deux \texttt{if... then... else ...} en séquence (figure~\ref{if_2seq}). La première condition est notée \texttt{x} et la deuxième \texttt{y}, nous avons étiquettés les 4 arcs correspondants aux branchements conditionnels : \texttt{x}, \texttt{\textlnot x}, \texttt{y}, \texttt{\textlnot y}.
  
  
%   \begin{figure}
%     \centering
%     \includegraphics[scale=0.45]{./pictures/if_2seq.png}
%     % if_2seq.png: 363x661 pixel, 72dpi, 12.80x23.32 cm, bb=0 0 363 661
%     \caption{Premier exemple : deux if en séquence}
%     \label{if_2seq}
%   \end{figure}
  \begin{wrapfigure}{R}{0in}
    \centering
    \includegraphics[scale=0.4]{./pictures/if_2seq.png}
    % if_2seq.png: 363x661 pixel, 72dpi, 12.80x23.32 cm, bb=0 0 363 661
    \caption{Premier exemple : deux if en séquence}
    \label{if_2seq}
  \end{wrapfigure}
  
  Nous notons $n_x$, $n_{\neg x}$, $n_y$ et $n_{\neg y}$ les variables qui représentent le nombre de fois que sont exécutés les arcs respectifs \texttt{x}, \texttt{\textlnot x}, \texttt{y}, et \texttt{\textlnot y}.
  
  Le problème est le suivant : nous savons que le chemin \texttt{x-y} (je note ainsi le seul chemin qui passe par les arcs notés \texttt{x} et \texttt{y}) est infaisable. Quelles contraintes ILP peut-on en déduire ?
  
  Attention, nous ne cherchons pas à trouver une équivalence (chemin infaisable $\Leftrightarrow$ contraintes ILP) mais simplement une implication (chemin infaisable $\Rightarrow$ contraintes ILP).
  
  \medbreak
  
  Pour un tel chemin infaisable \texttt{x-y}, l'\textit{unique} contrainte ILP que nous générons est la suivante :
  
  \[ n_x \leq n_{\neg y} \]
  
  Intuitivement, cette contrainte est valide (c'est-à-dire qu'elle est toujours vraie si \texttt{x-y} est un chemin infaisable) :
  
  En effet, si \texttt{x-y} est un chemin infaisable, alors tous les chemins qui passent par \texttt{x} passeront forcément par \texttt{\textlnot y}. Donc le nombre de fois que l'arc \texttt{\textlnot y} est exécuté, noté $n_{\neg y}$, est nécessairement \textit{supérieur ou égal} au nombre de fois que l'arc \texttt{x} est exécuté, c'est-à-dire $n_x$ (c'est supérieur s'il existe des chemins \texttt{\textlnot x-y}). Cela se traduit bien par 
  
  \[ n_x \leq n_{\neg y} \]
  
  On pourrait observer que de même, puisque \texttt{x-y} est un chemin infaisable, alors tous les chemins qui passent par \texttt{y} passeront forcément par \texttt{\textlnot x}, et donc que :
  
  \[ n_y \leq n_{\neg x} \]
  
  Nous allons maintenant montrer que $n_x \leq n_{\neg y} \Leftrightarrow n_y \leq n_{\neg x}$ et que par conséquent générer ces deux contraintes au lieu d'une seule est \textit{superflu}. Pour cela nous allons utiliser la propriété de flots de graphes qui dit que
  
  \[ n_x + n_{\neg x} = n_y + n_{\neg y} = N\]
  
  où N est une constante (qui représente le nombre total d'exécutions du programme). Nous avons ainsi :
  
  \begin{align*}
    n_x &\leq n_{\neg y} \\
    \Leftrightarrow n_x + (n_{\neg x} - n_{\neg x}) &\leq n_{\neg y} + (n_y - n_y) \\
    \Leftrightarrow (n_x + n_{\neg x}) - n_{\neg x} &\leq (n_{\neg y} + n_y) - n_y \\
    \Leftrightarrow N - n_{\neg x} &\leq N - n_y \\
    \Leftrightarrow - n_{\neg x} &\leq - n_y \\
    \Leftrightarrow n_y &\leq n_{\neg x} & \pushright{\blacksquare}
  \end{align*}
  
  \subsection{Cas avec trois if en séquence}
  \begin{wrapfigure}{R}{3.5in}
    \centering
    \includegraphics[scale=0.4]{./pictures/if_3seq.png}
    % if_3seq.png: 363x923 pixel, 72dpi, 12.80x32.56 cm, bb=0 0 363 923
    \caption{Deuxième exemple : trois if en séquence}
    \label{if_3seq}
  \end{wrapfigure}
  
  Voyons maintenant ce qui se passe lorsque l'on rajoute un autre \texttt{if... then... else ...} en séquence, ainsi que deux arcs notés \texttt{z} et \texttt{\textlnot z}.
  
  %TODO
  
  \subsection{Généralistion}
  
  \subsection{Limites des contraintes ILP}
  voir dans le dossier rapport/ !
  
  \pagebreak
  \section*{Conclusion}
  Petit récap...\\
  Tout ce qu'il y a à faire en thèse !\\
  Parler un peu de la théorie, analyse statique...\\

\newpage{}
%\bibliographystyle{plain}
\begin{thebibliography}{1}
    \bibitem{ARM instruction set} ARM Instruction Set Quick Reference Card. \url{http://infocenter.arm.com/help/topic/com.arm.doc.qrc0001l/QRC0001_UAL.pdf}
    \bibitem{SMT-COMP} SMT-COMP: Satisfiability Modulo Theories Competition. Édition 2012. \url{http://smtcomp.sourceforge.net/2012/}
    
    \bibitem{smt_z3} SMT solver Z3. \url{http://z3.codeplex.com/}
    \bibitem{smt_cvc4} SMT solver CVC4. \url{http://cvc4.cs.nyu.edu/web/}
    \bibitem{smt_mathsat5} SMT solver MathSAT 5. \url{http://mathsat.fbk.eu/documentation.html}
    \bibitem{smt_boolector} SMT solver Boolector. \url{http://fmv.jku.at/boolector/}
    \bibitem{smt_sonolar} SMT solver SONOLAR. \url{http://www.informatik.uni-bremen.de/~florian/sonolar/}
    \bibitem{smt_mistral} SMT solver MISTRAL. \url{http://www.cs.wm.edu/~tdillig/mistral/index.html}
    \bibitem{smt_verit} SMT solver VeriT. \url{http://www.verit-solver.org/veriT-download.php}
    \bibitem{smt_barcelogic} SMT solver Barcelogic. \url{http://www.lsi.upc.edu/~oliveras/bclt-main.html}
\end{thebibliography}

\end{document}


% http://infocenter.arm.com/help/topic/com.arm.doc.qrc0001l/QRC0001_UAL.pdf
% ARM Instruction Set Quick Reference Card