\documentclass[french,english]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{babel}
\usepackage{color}
\usepackage{colortbl}
\usepackage{listings}
\usepackage{pxfonts}
\usepackage[french]{algorithm2e}
\usepackage{url}
\usepackage{lstlangarm}

\lstset{
    language=Caml,
    basicstyle=\ttfamily,
    keywordstyle=\color[rgb]{0.5,0,0}\bfseries,
    commentstyle=\color[rgb]{0.133,0.545,0.133},
    showstringspaces=false,
    frame=tb,
    columns=fullflexible,
    morekeywords={undefined}
}

\definecolor{Gray}{gray}{0.85}

\makeatletter
\renewcommand{\@algocf@capt@plain}{above}% formerly {bottom}
\newcommand{\pushline}{\Indp} % Indent
\newcommand{\popline}{\Indm}  % Undent
\makeatother

\begin{document}
  \begin{titlepage}
  \newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
  \center 
  \textsc{\	 IRIT - Equipe TRACES}\\[1.5cm] \textsc{\Large Rapport de Stage - M2R IT Spé. SRLC}\\[0.5cm] 
  \textsc{\large 01 Mars 2014 - 03 Août 2014}
  \HRule \\[0.5cm] { \huge \bfseries Détermination de propriétés de flot de données pour l'amélioration du temps d'exécution
pire-cas}\\[0.4cm] \HRule \\[1cm]
  \begin{minipage}{0.5\textwidth} \begin{flushleft} \large \emph{Auteur:}\\ Jordy \textsc{Ruiz} \end{flushleft} \end{minipage}\begin{minipage}{0.5\textwidth} \begin{flushright} \large \emph{Encadrant:} \\ Hugues \textsc{Cassé}\end{flushright} \end{minipage}\\[1cm]
  {\large Année 2013 - 2014}\\[2.5cm]
  \includegraphics[scale=0.6]{pictures/logo_univ_tlse.png}\\[1cm]
  \vfill
  \end{titlepage}
  
  \pagebreak{}
  %\tableofcontents{}
  %\newpage{}

  \section{Introduction}
  \subsection{WCET, les enjeux}
  \`A Toulouse même, les besoins des industriels en termes de vérification de logiciel sont présents. Le calcul du pire temps d'exécution, ou WCET en anglais (Worst Case Execution Time) est un de ces multiples processus de vérification. La grande majorité des logiciels développés n'ont pas besoin de tels procédés de vérification, les bugs y sont gênants mais la plupart du temps on redémarre sans trop chercher à comprendre. Pour les systèmes dits \textbf{temps-réel critiques} (algorithme dans un satellite, frein d'une voiture, pilotage d'une rame de métro...), une erreur ou un échec peuvent entraîner de lourdes pertes économiques ou humaines : le plantage du logiciel d'un satellite nécessite des interventions très coûteuses, le temps de réponse exceptionnellement long d'un frein de voiture peut entraîner un accident...
  
  Le problème est simple : il peut exister dans ces systèmes temps-réel critiques des cas extrêmement rares, indétectables par une batterie de tests, où le temps d'exécution explose anormalement. On pourrait par exemple imaginer un algorithme qui sauvegarde (disons hebdomadairement) le contenu de ses données sur un disque externe. Si tout est géré de manière synchrone et qu'un ordre critique arrive à ce moment-là, on pourrait se retrouver avec un temps d'exécution très élevé. On peut imaginer plein d'autres exemples (une plage de données très fragmentée qui entrainerait des défauts de page en masse, etc...).
  
  Dans le cadre de mon étude, je fais abstraction de certains problèmes très bas niveau comme la gestion du cache ou le fonctionnement du pipeline et des prédictions de branchement. Ces problèmes ne sont pas ignorés, ils sont simplement traités par d'autres travaux, d'autres outils que les miens.
  
  Le calcul du WCET consiste en une \textbf{surestimation} : on ne donne certes pas une mesure exacte du pire temps d'exécution, mais on garantit que cette mesure est en tout cas supérieure au pire temps réel. Le but de mon étude est d'améliorer, d'affiner, donc de \textbf{réduire} la surestimation du WCET calculée par notre outil OTAWA, tout en restant correct. On cherche à avoir le plus petit majorant possible.
  
  La stratégie que je vais mettre en oeuvre pour la réduction de notre évaluation du WCET est la recherche de chemins infaisables.
  
  \subsection{La recherche de chemins infaisables}
  L'idée est la suivante : pour (sur)estimer le WCET, notre outil OTAWA fonctionne par énumération implicite des ``chemins'' du programme, ou IPET en anglais (Implicit Path Enumeration Technique), il prendra ensuite le temps d'exécution du chemin le plus coûteux du programme pour le calcul du WCET. Les programmes étudiés contiennent souvent de nombreux chemins infaisables (une étude avait observé 99.9\% de chemins infaisables dans un programme de gestion des vitres d'une voiture). Prenons par exemple le programme suivant :
  
  \RestyleAlgo{boxed}
  \begin{algorithm}
    \Donnees{n}
    \Res{k}
    \eSi{n > 10}{
	k = 0; // (1)\\
	sauvegarder();
    }{
	k = 1; // (2)
    }
    \eSi{n > 0}{
	k = k + 1; // (3)
    }{
	k = k - 1; // (4)\\
	sauvegarder();
    }
    \caption{Exemple d'un programme avec chemin infaisable}
  \end{algorithm}
  
  Ce programme contient 4 chemins :
  \begin{itemize}
    \item Un chemin $c_1$ qui passe par (1) et (3) ;
    \item Un chemin $c_2$ qui passe par (1) et (4) ;
    \item Un chemin $c_3$ qui passe par (2) et (3) ;
    \item Un chemin $c_4$ qui passe par (2) et (4).
  \end{itemize}
  
  Le chemin $c_2$, qui passe par (1) et (4) est \textbf{infaisable}, puisqu'il implique $n > 10$ et $n \ngtr 0$.
  
  On pourrait maintenant imaginer que la fonction \texttt{sauvegarder} fait une opération relativement coûteuse, comme par exemple une écriture sur un fichier du système. Dans ce cas, le WCET calculé correspondra au temps d'exécution du chemin $c_2$, qui vaut à peu près à deux fois le temps d'exécution de la fonction \texttt{sauvegarder}.
  
  Or, ce chemin est infaisable, c'est-à-dire qu'il ne sera jamais emprunté par le programme. Dans la réalité, ce programme n'exécuterait au plus qu'une fois cette fonction de sauvegarde, nous avons donc estimé le WCET (à peu près) au double du WCET réel !
  
  En détectant ce chemin infaisable $c_2$, on pourrait indiquer à OTAWA de ne pas considérer ce chemin, et ainsi réduire effectivement l'estimation du WCET obtenue de moitié.
  
  Le but de mon étude est donc de détecter ces chemins infaisables et de transmettre cette information à l'outil avant qu'il ne démarre son analyse pour l'estimation du WCET.

  
  \subsection{Langages supportés}
  Notre analyse portera sur des programmes écrits en \textbf{langage assembleur}, qui est le langage de programmation le plus proche de la machine. Le travail sur le code source a effectivement de multiples inconvénients : il faut prouver le(s) compilateur(s) qui viennent avec (un travail très conséquent), et cela nous restreint aussi aux programmes dont nous disposons des sources complètes (certaines bibliothèques ne sont pas open-source).
  
  Le langage assembleur, aussi appelé langage machine, est en revanche bien sûr beaucoup moins facile à analyser : les registres ne sont en général pas typés, et il n'y a pas réellement d'instructions \texttt{if}, \texttt{then}, \texttt{else} ou \texttt{while}, \texttt{for} (celle-ci est particulièrement dure à détecter dans le code assembleur) : il s'agit seulement d'instructions de comparaison et de branchements conditionnels. 
  
  Il n'y a pas non plus d'appels de fonctions avec des paramètres et des valeurs de retours explicites, il s'agit là encore de branchements (BL, Branch with Link dans le cas du langage d'assembleur ARM~\cite{ARM instruction set}).
  
  Un autre problème des langages machines est qu'il sont spécifiques à une architecture, les exécutables compilés à partir d'un même langage source seront différent selon qu'on est sur une architecture ARM ou PowerPC... Fort heureusement, notre outil OTAWA nous permet de nous \textbf{abstraire de l'architecture} en transformant les instructions du langage assembleur en \textbf{instructions sémantiques} génériques, universelles à tous les langages assembleur. % TODO: what is going on with the text align o_o
  
  Ainsi, l'analyse que je développerai avec OTAWA supportera toutes les architectures supportées par OTAWA, et pour supporter une nouvelle architecture, il suffit de rajouter celle-ci dans OTAWA. OTAWA fonctionne comme une interface entre l'analyse et le code (écrit dans un langage spécifique à une architeture). Cette interface est schématisée sur la figure~\ref{abstraction architecture}.
  
  \begin{figure}
    \centering
    \includegraphics[width=\textwidth]{pictures/otawa_abstraction_architecture.png}
    \caption{OTAWA permet aux analyses de s'abstraire de l'architecture}
    \label{abstraction architecture}
  \end{figure}
  
  Voici, sans donner plus de détails pour le moment, à quoi ressemble la traduction de code assembleur (celui-ci a été généré avec gcc) en instructions sémantiques. Les \texttt{tX} sont des variables temporaires utilisées pour la traduction en instructions sémantiques et les \texttt{?X} sont les registres. Pour chaque instruction assembleur, on trouve dessous une ou plusieurs instructions sémantiques équivalentes, en commentaire :
  
  \begin{lstlisting}[language={[ARM]Assembler}]
    ldr r0, [pc, #20]
    @	seti ?15, 0x8310
    @	seti t2, 0x14
    @	add t1, ?15, t2
    @	load ?0, t1, uint32
    
    mov r1, #0
    @	seti ?1, 0x0
    
    mov r2, r1
    @	set t1, ?1
    @	set ?2, t1
    
    bl 8574
    @	seti t1, 0x8574
    @	seti ?14, 0x8318
    @	branch t1
  \end{lstlisting}
  
  De plus amples explications à ce sujet seront données dans la suite de ce mémoire.
  
  \subsection{Restrictions}
  programmes sans boucles\\
  gestion de la mémoire limitée\\
  gestion unsigned/signed\\
  bien sûr toutes les instructions non gérées par otawa...\\
  
  \section{Brouillon}
  \subsection{Analyse d'un graphe de flot de contrôle}
  Nous travaillons sans boucles, cet algorithme n'est pas correct (il ne terminera pas) si on le fait fonctionner sur un CFG avec boucles. Nous initialisons d'abord l'algorithme de parcours de graphe de contrôle avec le premier bloc de base du CFG, qui nous est donné par OTAWA.
  
  Voici donc l'algorithme en pseudo-code, qui prend en paramètre un bloc de base :\\
  
   % http://www.cs.toronto.edu/~frank/Useful/algorithm2e.pdf
  \begin{algorithm}[H]
    % \caption{analyzeBasicBlock}
    \Donnees{bb: BasicBlock, lpreds: LabelledPredicate list}
    \Res{Chemins infaisables trouvés}
    \Si{bb est un bloc de sortie (EXIT)}{
        \Retour{[]} // Fin de l'analyse de ce chemin
    }
    Appeler le solveur SMT avec lpreds;\\
    \Si{on a trouvé une insatisfiabilité}{
	Extraire la liste des chemins infaisables;\\
	\Retour{cette liste} // Fin de l'analyse de ce chemin
    }
    preds = parseBasicBlock(bb); // Analyse linéaire des instructions sémantiques\\
    \Pour{tous les arcs sortants edge de bb}{
	Labeller les prédicats preds avec l'arc edge comme étiquette;\\
	Ajouter ces prédicats labellés à lpreds;\\
	Appel récursif de cette fonction avec pour paramètres (\\
	    \pushline le bloc de base vers lequel edge pointe,\\
	    la nouvelle liste lpreds\\
	\popline);\\
    }
  \end{algorithm}
  
  
  \subsection{Analyse des instructions sémantiques d'un bloc de base}
  Le programme parcourt les blocs de base linéairement en mettant à jour la liste de prédicats.

  Nous définissons d'abord une fonction d'invalidation d'une variable dans la liste de prédicats, qui consiste à supprimer tous les prédicats qui utilisent cette variable.

  \begin{lstlisting}[mathescape]
    invalidate var p =
        {predicate $\in$ p $|$ var $\notin$ predicate}
  \end{lstlisting}

  Il s'agit maintenant de définir l'effet de la lecture de chaque instruction sur la liste de prédicats.
  Exemple sur un premier cas trivial :

  \begin{lstlisting}
    t [NOP] p =
        p (* rien ne change *)
  \end{lstlisting}

  La fonction de traduction \texttt{t} opère sur une instruction (ici \texttt{NOP}) et la liste de prédicats \texttt{p}.

  Regardons maintenant comment est traitée l'instruction d'assignation d'une variable à une autre variable (\texttt{SET}) :

  \begin{lstlisting}
    t [SET d a] p =
        (d = a) @ (invalidate d p)
  \end{lstlisting}

  Un nouveau prédicat \texttt{d = a} est généré après qu'on ait invalidé \texttt{d}, c'est-à-dire qu'on ait supprimé tous les prédicats qui contiennent t.
  De même pour l'instruction \texttt{SETI} qui assigne une constante à une variable.

  \begin{lstlisting}
    t [SETI d cst] p =
        (d = a) @ (invalidate d p)

    t [CMP d a b] p =
        (d = a ~ b) @ (invalidate d p)
    \end{lstlisting}

    Cet opérateur $\sim$ bien spécifique aux langages d'assembleur sert à se souvenir que
    \texttt{d} contient des informations sur la comparaison entre \texttt{a} et \texttt{b}.

    Pour la suite nous allons avoir besoin de la fonction \texttt{update} qui sert à remplacer
    toutes les occurences d'une variable \texttt{var} par l'expression \texttt{expr} dans la liste de prédicats \texttt{p} :

  \begin{lstlisting}[mathescape]
    update var expr p =
        {predicate[expr / var] $|$ predicate $\in$ p}
  \end{lstlisting}

  où la syntaxe \texttt{predicate[expr / var]} dénote ici le prédicat où le terme \texttt{var} est remplacé par l'expression \texttt{expr}.

  \begin{lstlisting}[mathescape]
    t [ADD d a b] p =
        if (d = a) then (* d <- d+b *)
            (update d (d - b) p)
        else if (d = b) (* d <- a+d *)
            (update d (d - a) p)
        else
            (d = a + b) @ (invalidate d p)

    t [SUB d a b] p =
        if (d = a) then
            if (d = b) then (* d <- d-d *)
                (update d 0 p)
            else (* d <- d-b *)
                (update d (d+b) p)
        else
            if (d = b) then (* d <- a-d *)
                (update d (a-d) p)
            else (* d <- a-b *)
                (d = a - b) @ (invalidate d p)

    t [MUL d a b] p =
        if (d = a) then
            if (d = b) then (* d <- d*d *)
                (* impossible de remplacer d par $\sqrt{d}$, on invalide *)
                (0 <= d) @ (invalidate d p)
            else (* d <- d*b *)
                (* on rajoute un predicat pour indiquer que d est
                   divisible par b *)
                (d % b = 0) @ (update d (d/b) p)
        else
            if (d = b) then (* d <- a*d *)
                (d % a = 0) @ (update d (d/a) p)
            else (* d <- a*b *)
                (d = a * b) @ (invalidate d p)

    t [DIV d a b] p =
        if (d = a) then
            if (d = b) then (* d <- d/d *)
                (d = 1) @ (invalidate d p)
            else (* d <- d/b *)
                (* impossible de remplacer d par (d*b),
                   on a perdu de l'information ! *)
                (invalidate d p)
        else
            if (d = b) then (* d <- a/d *)
                (invalidate d p)
            else (* d <- a/b *)
                (d = a / b) @ (invalidate d p)
  \end{lstlisting}

  Pour illustrer le problème de l'instruction DIV, prenons le cas où l'on a \texttt{\{t1 = 7, t2 = 3\}} et une instruction \texttt{[DIV t1 t1 t2]}.\\
  En remplaçant \texttt{t1} par \texttt{t1 * t2}, on obtiendrait \texttt{\{(t1 * t2 = 7), (t2 = 3)\}}, c'est-à-dire \texttt{(t1 * 3 = 7)}, ce qui est impossible puisqu'on travaille sur des entiers !

  \begin{lstlisting}
    t [MOD d a b] p =
        if (d = a or d = b)
            (invalidate d p)
        else
            (d = a % b) @ (invalidate d p)
  \end{lstlisting}

  Nous utiliserons dans la suite une fonction \texttt{eval} qui cherche la valeur \textbf{constante} pour une variable.
  La fonction eval parcourt donc la liste des prédicats à la recherche de prédicats du type \texttt{(var = 2)} permettant
  d'identifier la valeur de \texttt{var}.

  \begin{lstlisting}
    t [ASR d a b] p =
        let b_val = eval b in
        if b_val = undefined then
            (invalidate d p)
        else
            let factor = 2 ** b_val in
            if (d = a) then (* d <- d>>b *)
                (update d (d / factor) p)
            else (* d <- a>>b *)
                (d = a / factor) @ (invalidate d p)

    t [NEG d a] =
        if (a = d) (* d <- -d *)
            (update d (-d) p)
        else (* d <- -a *)
            (d = -a) @ (invalidate d p)
  \end{lstlisting}


  \begin{figure}
    \begin{tabular}{|l|l|} \hline
      \textbf{Instruction} & \textbf{Sémantique}\\ \hline \hline
      \texttt{NOP} & (rien)\\ \hline
      \texttt{BRANCH} & \\
      \texttt{TRAP} & Indicateurs du flot du programme\\
      \texttt{CONT} & \\ \hline
      \texttt{IF cond sr jump} & si la condition \texttt{cond} sur le registre \texttt{sr} est vraie, continuer,\\
      & sinon sauter \texttt{jump} instructions\\ \hline
      \texttt{LOAD reg addr type} & reg $\leftarrow$ \texttt{MEM\textsubscript{type}} \\ \hline
      \texttt{STORE reg addr type} & \texttt{MEM\textsubscript{type}} $\leftarrow$ \texttt{reg}\\ \hline
      \texttt{SCRATCH d} & \texttt{d $\leftarrow$ $\top$} \textit{(invalidation)}\\ \hline
      \texttt{SET d a} & \texttt{d $\leftarrow$ a}\\ \hline
      \texttt{SETI d cst} & \texttt{d $\leftarrow$ cst}\\ \hline
      \rowcolor{Gray} \texttt{SETP d cst} & \texttt{page(d) $\leftarrow$ cst}\\ \hline
      \texttt{CMP d a b} & \texttt{d $\leftarrow$ a $\sim$ b}\\ \hline
      \rowcolor{Gray} \texttt{CMPU d a b} & \texttt{d $\leftarrow$ a $\sim$\textsubscript{unsigned} b}\\ \hline
      \texttt{ADD d a b} & \texttt{d $\leftarrow$ a $+$ b}\\ \hline
      \texttt{SUB d a b} & \texttt{d $\leftarrow$ a $-$ b}\\ \hline
      \rowcolor{Gray} \texttt{SHL d a b} & \texttt{d $\leftarrow$ unsigned(a) <{<} b}\\ \hline
      \rowcolor{Gray} \texttt{SHR d a b} & \texttt{d $\leftarrow$ unsigned(a) >{>} b}\\ \hline
      \texttt{ASR d a b} & \texttt{d $\leftarrow$ a >{>} b}\\ \hline
      \texttt{NEG d a} & \texttt{d $\leftarrow$ $-$a}\\ \hline
      \rowcolor{Gray} \texttt{NOT d a} & \texttt{d $\leftarrow$ $\neg$a}\\ \hline
      \rowcolor{Gray} \texttt{AND d a b} & \texttt{d $\leftarrow$ a \& b}\\ \hline
      \rowcolor{Gray} \texttt{OR d a b} & \texttt{d $\leftarrow$ a | b}\\ \hline
      \rowcolor{Gray} \texttt{XOR d a b} & \texttt{d $\leftarrow$ a $\oplus$ b}\\ \hline
      \texttt{MUL d a b} & \texttt{d $\leftarrow$ a $\times$ b}\\ \hline
      \rowcolor{Gray} \texttt{MULU d a b} & \texttt{d $\leftarrow$ unsigned(a) $\times$ unsigned(b)}\\ \hline
      \texttt{DIV d a b} & \texttt{d $\leftarrow$ a / b}\\ \hline
      \rowcolor{Gray} \texttt{DIVU d a b} & \texttt{d $\leftarrow$ unsigned(a) / unsigned(b)}\\ \hline
      \texttt{MOD d a b} & \texttt{d $\leftarrow$ a \% b}\\ \hline
      \rowcolor{Gray} \texttt{MODU d a b} & \texttt{d $\leftarrow$ unsigned(a) \% unsigned(b)}\\ \hline
      \rowcolor{Gray} \texttt{SPEC} & (instruction spéciale non supportée par OTAWA)\\ \hline
    \end{tabular}
    \textit{En gris : les instructions qui ne sont pas (encore) traitées par notre analyse.}
    \caption{Liste des instructions sémantiques d'OTAWA}
  \end{figure}


  \section{Solution}
  Explication : calcul de WCET par IPET, max d'un système ILP\\
  Solution = Recherche de chemins infaisables pour améliorer l'estimation du WCET\\
  Parler des outils choisis (OTAWA + CVC4 ?)\\

  \section{Structures de données utilisées}
  La représentation des prédicats (associés à un Edge)\\
  => représentation également de la mémoire\\
  Traduction des prédicats dans le solveur SMT

  \section{Structure de l'algorithme}
  CFG : Représentation du programme sous la forme de graphe\\
  On parcourt tous les chemins\\
  On les représente sous la forme de prédicats (on y associe un arc du CFG\\
  On fait des appels au SMT pour vérifier la satisfiabilité\\
  Retourne la liste de prédicats\\
  On génère les contraintes ILP\\
  
  \section*{Conclusion}
  Petit récap...\\
  Tout ce qu'il y a à faire en thèse !\\
  Parler un peu de la théorie, analyse statique...\\

\newpage{}
%\bibliographystyle{plain}
\begin{thebibliography}{1}
    \bibitem{ARM instruction set} ARM Instruction Set Quick Reference Card.\\ \url{http://infocenter.arm.com/help/topic/com.arm.doc.qrc0001l/QRC0001_UAL.pdf}
\end{thebibliography}

\end{document}


% http://infocenter.arm.com/help/topic/com.arm.doc.qrc0001l/QRC0001_UAL.pdf
% ARM Instruction Set Quick Reference Card