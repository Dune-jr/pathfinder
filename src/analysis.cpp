/*
 * General analysis methods
 */

#include "analysis_state.h"
#include "cfg_features.h"
#include <otawa/cfg/Edge.h>

/**
 * @class Analysis
 * @brief Perform an infeasible path analysis on a CFG 
 */
Analysis::Analysis(const context_t& context, int state_size_limit, int flags)
	: context(context), state_size_limit(state_size_limit), flags(flags)
	, ip_count(0), unminimized_ip_count(0)
	, loop_header_count(0), bb_count(-1)
{
	DBG("Stack pointer identified to r" << context.sp)
}

const Vector<DetailedPath>& Analysis::run(CFG *cfg)
{
	bb_count = cfg->count()-1; // do not count ENTRY
	processCFG(cfg);
	return infeasiblePaths();
}

/**
 * @fn Vector<DetailedPath> Analysis::infeasiblePaths();
 * @brief Retrieve the vector of infeasible paths generated by the analysis
 */

/*
 * @fn void Analysis::debugProgress(int block_id, bool enable_smt) const;
 * Print progress of analysis
 */
void Analysis::debugProgress(int block_id, bool enable_smt) const
{
	if(dbg_verbose >= DBG_VERBOSE_RESULTS_ONLY && (dbg_flags&DBG_PROGRESS))
	{
		static int processed_bbs = 0;
		if(enable_smt)
			++processed_bbs; // only increase processed_bbs when we are in a state where we are no longer looking for a fixpoint
		cout << "[" << processed_bbs*100/bb_count << "%] Processed Block #" << block_id << " of " << bb_count << "        " << endl << "\e[1A";
	}
}

/*
 * @fn void Analysis::wl_push(Block* b);
 * @brief push b in wl, ensuring unicity in wl
 */
void Analysis::wl_push(Block* b)
{
	ASSERTP(!b->isUnknown(), "Block " << b << " is unknown, not supported by analysis.");
	if(b->isCall()) 
		b = b->toSynth()->callee()->entry(); // call becomes callee entry
	if(b->isExit())
		b = getCaller(b, b); // exit becomes caller (remains exit if no caller)
	if(!wl.contains(b))
	{
		wl.push(b);
		// DBGG("-\twl ← wl ∪ " << b)
	}
}

/**
 * @fn Block* Analysis::insAlias(Block* b);
 * @brief Substitue a block with the appropriate block to get ingoing edges from
 * @rtn Block to substitute b with (by default, b)
 */
Block* Analysis::insAlias(Block* b)
{
	if(b->isEntry()) // entry becomes caller
	{
		Option<Block*> rtn = getCaller(b->cfg());
		ASSERTP(rtn, "insAlias called on main entry - no alias with ins exists")
		return rtn;
	}
	else if(b->isCall()) // call becomes exit
		return b->toSynth()->callee()->exit();
	return b;
}
/**
 * @fn static Vector<Edge*> allIns (Block* h);
 * @brief
 * @rtn return the list of edges
 */
Vector<Edge*> Analysis::allIns(Block* h)
{
	Vector<Edge*> rtn(4);
	for(Block::EdgeIter i(insAlias(h)->ins()); i; i++)
		rtn.push(*i);
	if(dbg_verbose < DBG_VERBOSE_RESULTS_ONLY) cout << endl;
	DBGG("-" << color::ICya() << h << color::RCol() << " " << printFixPointStatus(h))
	return rtn;
}
/**
 * @fn static Vector<Edge*> backIns(Block* h);
 * @brief
 * @rtn return the list of edges
 */
Vector<Edge*> Analysis::backIns(Block* h)
{
	Vector<Edge*> rtn(4);
	for(Block::EdgeIter i(insAlias(h)->ins()); i; i++)
		if(BACK_EDGE(*i))
			rtn.push(*i);
	if(dbg_verbose < DBG_VERBOSE_RESULTS_ONLY) cout << endl;
	DBGG("-" << color::ICya() << h << color::RCol() << " " << printFixPointStatus(h))
	return rtn;
}
/**
 * @fn static Vector<Edge*> nonBackIns(Block* h);
 * @brief
 * @rtn return the list of edges
 */
Vector<Edge*> Analysis::nonBackIns(Block* h)
{
	Vector<Edge*> rtn(4);
	for(Block::EdgeIter i(insAlias(h)->ins()); i; i++)
		if(!BACK_EDGE(*i))
			rtn.push(*i);
	if(dbg_verbose < DBG_VERBOSE_RESULTS_ONLY) cout << endl;
	DBGG("-" << color::ICya() << h << color::RCol() << " " << printFixPointStatus(h))
	return rtn;
}

/**
  * @brief check that all the loops this exits from are "LEAVE" status
  * aka e ∈ exits\{EX_h | src(e) ∈ L_h ∧ status_h ≠ LEAVE}
*/
bool Analysis::isAllowedExit(Edge* exit_edge)
{
	Block* outer_lh = LOOP_EXIT_EDGE(exit_edge);
	//*
	for(LoopHeaderIter lh(exit_edge->source()); lh; lh++)
	{
		if(loopStatus(lh) != LEAVE)
			return false;
		if(lh == outer_lh) // stop here
			break;	
	}
	return true;
	//*/
	/*
	Block* lh = LOOP_HEADER(exit_edge->source()) ? exit_edge->source() : ENCLOSING_LOOP_HEADER(exit_edge->source()); // initialize to the inner loop
	while(ENCLOSING_LOOP_HEADER.exists(lh) && lh != outer_lh) // we will have to iterate one more time, either way
	{
		if(loopStatus(lh) != LEAVE)
			return false;
		lh = ENCLOSING_LOOP_HEADER(lh); // enclosing loop header should always exist until we reach outer_lh!
	}
	return loopStatus(lh) == LEAVE; // do last check
	//*/
}

/* for e ∈ outs \ {EX_h | b ∈ L_h ∧ status_h ≠ LEAVE} */
Vector<Edge*> Analysis::outsWithoutUnallowedExits(Block* b)
{
	if(b->isExit()) {
		DBGG(color::IGre() << "Reached end of program.")
		return nullVector<Edge*>();
	}
	Vector<Edge*> rtn(4);
	for(Block::EdgeIter i(b->outs()); i; i++)
		if(! LOOP_EXIT_EDGE.exists(*i) || isAllowedExit(*i))
			rtn.push(*i);
	ASSERTP(rtn, "outsWithoutUnallowedExits found no outs!")
	if(dbg_verbose < DBG_VERBOSE_RESULTS_ONLY)
	{
		Vector<Edge*>::Iterator i(rtn);
		DBGG("-\toutput to " << i->source())
		for(; i; i++)
			DBGG("\t\t  ->" << i->target())
	}
	return rtn;
}

String Analysis::printFixPointStatus(Block* b)
{
	String rtn = "[";
	for(LoopHeaderIter i(b); i; i++)
	{
		switch(loopStatus(*i))
		{
			case ENTER:
				rtn = rtn.concat(color::IRed() + "E");
			break;
			case FIX:
				rtn = rtn.concat(color::Yel() + "F");
			break;
			case LEAVE:
				rtn = rtn.concat(color::IGre() + "L");
			break;
		}
	}
	return rtn + color::RCol() + "]";
}
