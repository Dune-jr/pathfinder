/*
 * General analysis methods
 */

#include "analysis_state.h"
#include <otawa/cfg/Edge.h>

/**
 * @class Analysis
 * @brief Perform an infeasible path analysis on a CFG 
 */
Analysis::Analysis(const context_t& context, int state_size_limit, int flags)
	: context(context), state_size_limit(state_size_limit), flags(flags)
	, loop_header_count(0), bb_count(-1)
	, ip_count(0), unminimized_ip_count(0)
{
	DBG("Stack pointer identified to r" << context.sp)
}

const Vector<DetailedPath>& Analysis::run(CFG *cfg)
{
	bb_count = cfg->count()-1; // do not count ENTRY
	processCFG(cfg);
	return infeasiblePaths();
}

/**
 * @fn Vector<DetailedPath> Analysis::infeasiblePaths();
 * @brief Retrieve the vector of infeasible paths generated by the analysis
 */

// PredIterator
void Analysis::State::setPredicate(PredIterator &iter, const LabelledPredicate &labelled_predicate)
{
	ASSERT(!iter.ended());
	if(iter.state == PredIterator::GENERATED_PREDS)
		generated_preds.set(iter.gp_iter, labelled_predicate);
	else if(iter.state == PredIterator::LABELLED_PREDS)
		labelled_preds.set(iter.lp_iter, labelled_predicate);
	else DBG(color::BIRed() << "Analysis::setPredicate(): unhandled iter.state!")
}

/**
 * @fn void Analysis::State::movePredicateToGenerated(PredIterator &iter);
 * @brief Move predicates to the local list (so that they get updated with an edge)
 * @warning this may result in iter.ended()!
**/
void Analysis::State::movePredicateToGenerated(PredIterator &iter)
{
	if(iter.state == PredIterator::GENERATED_PREDS)
		return; // do not do anything
	else if(iter.state == PredIterator::LABELLED_PREDS)
	{
		generated_preds += *iter;
		labelled_preds.remove(iter.lp_iter);
		iter.updateState();
	}
	else DBG(color::BIRed() << "Analysis::movePredicateToGenerated(): unhandled iter.state!")
}

void Analysis::State::removePredicate(PredIterator &iter)
{
	ASSERT(!iter.ended());
	if(iter.state == PredIterator::GENERATED_PREDS)
		generated_preds.remove(iter.gp_iter);
	else if(iter.state == PredIterator::LABELLED_PREDS)
		labelled_preds.remove(iter.lp_iter);
	else DBG(color::BIRed() << "Analysis::removePredicate(): unhandled iter.state!")
	iter.updateState();
}

SLList<LabelledPredicate> Analysis::State::labelPredicateList(const SLList<LabelledPredicate>& pred_list, Edge* label)
{
	SLList<LabelledPredicate> rtn;
	for(SLList<LabelledPredicate>::Iterator iter(pred_list); iter; iter++)
	{
		LabelledPredicate lp(*iter);
		lp.addLabel(label);
		rtn += lp;
	}
	return rtn;
}

io::Output& Analysis::State::print(io::Output& out) const
{
	// out << ":" << labelled_preds << "/" << constants;
	if(isBottom())
		// return (out << getPathString()); // TODO!
		return (out << path);
	else
#		ifndef NO_UTF8
			return (out << "⊥");
#		else
			return (out << "(bottom)");
#		endif
}

/**
 * @fn void Analysis::State::merge(const SLList<State>& sl);
 * Modifies the current state to be the result of the merge of an (SL)list of states 
 */
/*void Analysis::State::merge(const SLList<State>& sl)
{
	DBGG("-\tmerging " << sl)
	// resetting stuff
	generated_preds.clear();
	generated_preds_taken.clear();
	labelled_preds.clear();
	SLList<ConstantVariables> cvl;
	// intialize to first element
	ASSERTP(!sl.isEmpty(), "call to Analysis::State::merge with empty sl parameter"); // maybe just leave the state empty
	constants = sl.first().constants;
	// copy firstElement.labelled_preds into labelled_preds with empty labels
	for(SLList<LabelledPredicate>::Iterator iter(sl.first().labelled_preds); iter; iter++)
		labelled_preds += LabelledPredicate(iter->pred(), Path::null);
	bool first = true;
	for(SLList<State>::Iterator sl_iter(sl); sl_iter; sl_iter++)
	{
		if(first) // the first element is s itself, it's useless to merge s with s
		{
			first = false;
			continue;
		}
		// for each element of labelled_preds, we make sure it is in *sl_iter
		for(SLList<LabelledPredicate>::Iterator iter(labelled_preds); iter; )
		{
			// do not use 'if(s.labelled_preds.contains(*iter))' as we want to use Predicate::operator== and not LabelledPredicate::operator==
			bool contains = false;
			for(SLList<LabelledPredicate>::Iterator subiter((*sl_iter).labelled_preds); subiter; subiter++)
			{
				if((*subiter).pred() == iter->pred())
				{
					contains = true;
					break;
				}
			}
			if(contains)
				iter++;
			else
				labelled_preds.remove(iter);
		}
		cvl += (*sl_iter).constants; // constants.merge(...) uses the info from "constants" so it's useless to add it at the first iteration
	}
	this->constants.merge(cvl);
	this->path.merge(stateListToPathVector(sl)); // merge paths as well while keeping some flow info and shrink that in this->path
#ifdef DBGG
	// cout << color::Pur() << "result of merge, this->path=" << this->path.toString() << color::Pur() << ", *this=" << *this << color::RCol() << io::endl;
#endif
}*/

/*
 * @fn void Analysis::State::merge(const SLList<State>& sl, Edge* e);
 * Modifies the current state to be the result of the merge of an (SL)list of states 
 */
/*void Analysis::State::merge(const SLList<State>& sl, Edge* e)
{
	DBG(color::Whi() << "Merging " << sl.count() << " paths at BB " << e->source()->number())
	merge(sl);
	labelled_preds = labelPredicateList(labelled_preds, e);
	constants.label(e);
	path.merge(stateListToPathVector(sl)); // clears up path and merge all of sl into 1
	DBG("Merged predicates: " << generated_preds << ", " << constants)
}*/

/**
 * @fn inline Analysis::State Analysis::topState(Block* entry) const;
 * @brief Returns a \top state
 */
Analysis::State Analysis::topState(Block* entry) const
{
	return Analysis::State(entry, context);
}

/*
 * @fn void Analysis::debugProgress(int block_id, bool enable_smt) const;
 * Print progress of analysis
 */
void Analysis::debugProgress(int block_id, bool enable_smt) const
{
	if(dbg_verbose >= DBG_VERBOSE_RESULTS_ONLY && (dbg_flags&DBG_PROGRESS))
	{
		static int processed_bbs = 0;
		if(enable_smt)
			++processed_bbs; // only increase processed_bbs when we are in a state where we are no longer looking for a fixpoint
		cout << "[" << processed_bbs*100/bb_count << "%] Processed Block #" << block_id << " of " << bb_count << "        " << endl << "\e[1A";
	}
}

elm::String Analysis::State::dumpEverything() const
{
	return _
		<< "--- DUMPING WHOLE STATE ---" << endl
		<< "  * OrderedPath path=" << getPathString() << endl
		<< "  * ConstantVariables constants=" << constants << endl
		<< "  * SLList<LabelledPredicate> labelled_preds=" << labelled_preds << endl
		<< "  * SLList<LabelledPredicate> generated_preds=" << generated_preds << endl
		// << "  * SLList<LabelledPredicate> generated_preds_taken=" << generated_preds_taken << endl
		<< "--- END OF DUMP ---" << endl;
}

// this is not Leibniz equality, but a test to check for a fixpoint!
// <!> this compares labelled_preds only <!>
bool Analysis::State::equiv(const Analysis::State& s) const
{
	ASSERT(this->sp == s.sp);
	// do not check the path or any of the edges!
	/*if(generated_preds != generated_preds)
		return false;
	if(generated_preds_taken != generated_preds_taken)
		return false;
	*/
	if(!this->constants.sameValuesAs(s.constants))
		return false;
	// checking for this->labelled_preds.sameValuesAs(s.labelled_preds)
	if(this->labelled_preds.count() != s.labelled_preds.count())
		return false;
	for(SLList<LabelledPredicate>::Iterator self_iter(this->labelled_preds); self_iter; self_iter++)
	{
		bool contains = false;
		for(SLList<LabelledPredicate>::Iterator s_iter(s.labelled_preds); s_iter; s_iter++)
		{
			if(self_iter->pred() == s_iter->pred())
			{
				contains = true;
				break;
			}
		}
		if(!contains)
			return false;
	}
	DBGG("-	fixpoint!")
	return true;
}

/*
 * @fn void Analysis::wl_push(Block* b);
 * @brief push b in wl, ensuring unicity in wl
 */
void Analysis::wl_push(Block* b)
{
	ASSERTP(!b->isUnknown(), "Block " << b << " is unknown, not supported by analysis.");
	if(b->isCall()) 
		b = b->toSynth()->callee()->entry(); // call becomes callee entry
	if(b->isExit())
		b = getCaller(b); // exit becomes caller (remains exit if no caller)
	if(!wl.contains(b))
	{
		wl.push(b);
		// DBGG("-\twl ← wl ∪ " << b)
	}
}

/**
 * @fn Block* Analysis::insAlias(Block* b);
 * @brief Substitue a block with the appropriate block to get ingoing edges from
 * @rtn Block to substitute b with (by default, b)
 */
Block* Analysis::insAlias(Block* b)
{
	if(b->isEntry()) // entry becomes caller
	{
		Option<Block*> rtn = getCaller(b->cfg());
		ASSERTP(rtn, "insAlias called on main entry - no alias with ins exists")
		return rtn;
	}
	else if(b->isCall()) // call becomes exit
		return b->toSynth()->callee()->exit();
	return b;
}
/**
 * @fn static Vector<Edge*> allIns (Block* h);
 * @brief
 * @rtn return the list of edges
 */
Vector<Edge*> Analysis::allIns(Block* h)
{
	Vector<Edge*> rtn(4);
	for(Block::EdgeIter i(insAlias(h)->ins()); i; i++)
		rtn.push(*i);
	DBGG("-" << h << ", collecting allIns...")
	return rtn;
}
/**
 * @fn static Vector<Edge*> backIns(Block* h);
 * @brief
 * @rtn return the list of edges
 */
Vector<Edge*> Analysis::backIns(Block* h)
{
	Vector<Edge*> rtn(4);
	for(Block::EdgeIter i(insAlias(h)->ins()); i; i++)
		if(BACK_EDGE(*i))
			rtn.push(*i);
	DBGG("-" << h << ", collecting backIns...")
	return rtn;
}
/**
 * @fn static Vector<Edge*> nonBackIns(Block* h);
 * @brief
 * @rtn return the list of edges
 */
Vector<Edge*> Analysis::nonBackIns(Block* h)
{
	Vector<Edge*> rtn(4);
	for(Block::EdgeIter i(insAlias(h)->ins()); i; i++)
		if(!BACK_EDGE(*i))
			rtn.push(*i);
	DBGG("-" << h << ", collecting nonBackIns...")
	return rtn;
}

/**
  * @brief check that all the loops this exits from are "LEAVE" status
  * aka e ∈ exits\{EX_h | src(e) ∈ L_h ∧ status_h ≠ LEAVE}
*/
bool Analysis::isAllowedExit(Edge* exit_edge)
{
	Block* outer_lh = LOOP_EXIT_EDGE(exit_edge);
	//*
	for(LoopHeaderIter lh(exit_edge->source()); lh; lh++)
	{
		if(loopStatus(lh) != LEAVE)
			return false;
		if(lh == outer_lh) // stop here
			break;	
	}
	return true;
	//*/
	/*
	Block* lh = LOOP_HEADER(exit_edge->source()) ? exit_edge->source() : ENCLOSING_LOOP_HEADER(exit_edge->source()); // initialize to the inner loop
	while(ENCLOSING_LOOP_HEADER.exists(lh) && lh != outer_lh) // we will have to iterate one more time, either way
	{
		if(loopStatus(lh) != LEAVE)
			return false;
		lh = ENCLOSING_LOOP_HEADER(lh); // enclosing loop header should always exist until we reach outer_lh!
	}
	return loopStatus(lh) == LEAVE; // do last check
	//*/
}

/* for e ∈ outs \ {EX_h | b ∈ L_h ∧ status_h ≠ LEAVE} */
Vector<Edge*> Analysis::outsWithoutUnallowedExits(Block* b)
{
	if(b->isExit()) {
		DBGG(color::IGre() << "Reached end of program.")
		return nullVector<Edge*>();
	}
	Vector<Edge*> rtn(4);
	for(Block::EdgeIter i(b->outs()); i; i++)
		if(! LOOP_EXIT_EDGE.exists(*i) || isAllowedExit(*i))
			rtn.push(*i);
	ASSERTP(rtn, "outsWithoutUnallowedExits found no outs!")
	if(dbg_verbose < DBG_VERBOSE_RESULTS_ONLY)
	{
		Vector<Edge*>::Iterator i(rtn);
		DBGG("-\toutput to " << i->source())
		for(; i; i++)
			DBGG("\t\t  ->" << i->target())
	}
	return rtn;
}

/**
 * Option<Block*> Analysis::getCaller(CFG* cfg);
 * @brief return unique caller of CFG (none if no caller exists) in virtualized scenario
 */
Option<Block*> Analysis::getCaller(CFG* cfg)
{
	CFG::CallerIter citer(cfg->callers());
	if(citer)
	{
		// Block::EdgeIter caller_exit_edges_iter(citer->outs());
		// ASSERTP(caller_exit_edges_iter, "must be at least 1 outedge from caller (CFG not virtualized?)")
		// // PROCESSED_EDGES(*caller_exit_edges_iter) = sl;
		// Block* rtn = caller_exit_edges_iter->target();
		// ASSERTP(!(++caller_exit_edges_iter), "must be max 1 outedge from caller (CFG not virtualized?)")
		Block* rtn = citer;
		ASSERTP(!(++citer), "must be max. 1 caller (CFG not virtualized?)");
		return elm::some(rtn);
	}
	else // no caller: exiting main CFG
		return elm::none;
}

/**
 * get the call SynthBlock of the CFG corresponding to exit 
 * @warning: only works for virtualized CFG
 * @warning: returns parameter exit when no caller exists
 */
Block* Analysis::getCaller(Block* exit)
{
	ASSERT(exit->isExit());
	if(Option<Block*> rtn = getCaller(exit->cfg()))
		return *rtn;
	else // no caller: exiting main CFG
	{
		// DBG(color::IGre() << "Reached end of program." << color::RCol());
		return exit;
	}
}
